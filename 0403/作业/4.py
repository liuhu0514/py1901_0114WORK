from sys import getrefcount
"""
python高级：垃圾回收机制
    python采用的是引用计数机制为主， 标记-清理和分代收集两种机制为辅的策略
    引用计数
    引用计数+1的情况
    1.对象被创建时，例如a='hello lh'
    2.对象被复制引用时，例如b=a,此时a引用计数+1
    3.对象被作为参数，传入到一个函数中时
    4.对象作为一个子元素，存储到容器中时，例如 list=[a,b]
"""
print(getrefcount('lh'))
h = 'lh'
print(getrefcount('lh'))
a = h
print(getrefcount('lh'))
"""

    引用计数-1的情况
    1.对象别名被显示销毁，例如 del a
    2.对象引用被赋予新的对象，例如b=c，此时b引用计数-1（对照引用计数+1的情况下的第二点来看）
    3.一个函数离开他的作用域，例如函数执行完成，它的引用参数的引用计数-1
    4.对象所在容器被销毁，或者从容器中删除
"""
del a
print(getrefcount('lh'))
h = 'hello'
print(getrefcount('lh'))
"""
    引用计数机制优点
    1.简单、直观
    2.实时性，只要没有了引用就释放资源。
    引用计数机制缺点
    1.维护引用计数需要消耗一定的资源
    2.循环应用时，无法回收。也正是因为这个原因，才需要通过标记-清理和分代收集机制来辅助引用计数机制
"""
"""
    标记-清除
    内存A  付给list1  内存A引用 1
    内存B  付给list2  内存B引用 1
    内存C  付给list3/list4  内存C 引用2
    内存D  付给list6    内存D引用1
    
    
    list1 、list2 循环引用 内存A、内存B引用计数2
    
    list3 、list6 循环引用 内存C引用计数3、内存D引用计数2
    
    
    del list1  内存A引用 1
    del list2  内存B引用 1
    del list3  内存C引用 2
    del list6  内存D引用 1
    
    此时引用计数出现问题 永远不能被回收 泄露
    
    第一步 ：将删除的对象的引用计数都减1
    内存A 引用 0
    内存B 引用 0
    内存C 引用 1
    内存D 引用 0
    将内存引用计数为0 对象加入死亡容器  （A，B，D都在死亡容器）
    将内存引用计数不为0
    
"""
